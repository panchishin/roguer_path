<html>
<head>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
</head>
<style>body {margin: 0; background-color: black}</style>

<body>
<script src="https://threejs.org/build/three.min.js"></script>
<script type='module'>


let camera, scene, renderer, clock, textures;

const tilemap = [6, 0, 22, 8, 8, 21, 1, 5, 0, 22,
        20, 14, 21, 8, 8, 21, 8, 12, 7, 22,
        21, 22, 21, 8, 8, 22, 8, 19, 14, 21,
        0, 1, 5, 15, 15, 0, 8, 21, 22, 22,
        7, 8, 12, 13, 13, 7, 8, 22, 1, 1,
        14, 8, 12, 13, 13, 7, 8, 21, 8, 8,
        22, 8, 19, 20, 20, 14, 8, 21, 8, 8,
        21, 8, 21, 22, 21, 21, 8, 5, 15, 15,
        1, 8, 1, 5, 0, 21, 8, 19, 20, 20,
        8, 8, 8, 12, 7, 21, 8, 21, 22, 21]
;

const animations = {
        1: [[1, 2, 3, 4], 10],
        8: [[8, 9, 10, 11], 10],
        15: [[15, 16, 17, 18], 10],
        22: [[22, 23], 40]
    };
const fps = 60;

const tile_size = 16;

const cols = 8; // amount of columns
const rows = 3;  // amount of rows
const totalSprites = cols*rows; // amount of images of sprite sheet

init();
animate();

function init() {

    const width = 1600;
    const height = 1600;
    camera = new THREE.OrthographicCamera( -width/2, width/2, height/2, -height/2, -1, 1 );

    scene = new THREE.Scene();

    clock = new THREE.Clock();
    
    const loader = new THREE.TextureLoader();
    const texture = loader.load( 'wucpG7e.png' );

    texture.colorSpace = THREE.SRGBColorSpace;
    texture.magFilter = THREE.NearestFilter;
    
    texture.repeat.x = 1.0 / cols;
    texture.repeat.y = 1.0 / rows;

    textures = {};
    for (let imageIndex = 0 ; imageIndex < totalSprites ; imageIndex++ ){
        textures[imageIndex] = texture.clone();
        let col = ( imageIndex % cols ) / cols;
		let row = ( rows - Math.floor( imageIndex / cols ) - 1 ) / rows;
		
		textures[imageIndex].offset.x =	col;
		textures[imageIndex].offset.y = row;
    }

    const size = 16*5;
    for (let x=0; x<20; x++) {
        for (let y=0; y<20; y++) {
            const geometry = new THREE.PlaneGeometry( size, size );
            const imageIndex = tilemap[x%10 + (y%10)*10];
            const material = new THREE.MeshBasicMaterial( { map: textures[imageIndex] } );
            let mesh = new THREE.Mesh( geometry, material );
            mesh.position.set((x-9.5)*size,(9.5-y)*size,0);
            scene.add( mesh );
        }
    }
    renderer = new THREE.WebGLRenderer( { antialias: true } );
    renderer.setSize( 800,800 );
    document.body.appendChild( renderer.domElement );
}

function animate() {
   requestAnimationFrame( animate );

    if ( textures ) {
		
        const frames = clock.getElapsedTime() * fps;
    
        for (let i of Object.keys(animations)) {
            const [animation, timeStep] = animations[i];
            const step = Math.floor(frames / timeStep) % animation.length;
            const imageIndex = animation[step];

            let col = ( imageIndex % cols ) / cols;
    		let row = ( rows - Math.floor( imageIndex / cols ) - 1 ) / rows;
    		
    		textures[i].offset.x =	col;
    		textures[i].offset.y = row;
            //console.log(i + " " + step + " " + imageIndex + " " + row + " " + col);
        }
    }
    

    renderer.render( scene, camera );
}

</script>
</body>
</html>